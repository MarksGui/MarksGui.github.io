<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="在 MySQL 中，索引是在存储引擎层实现的，所以不同存储引擎即使支持同一类型索引，其实现方式也可能是不同的。 常见类型有：  B-Tree 索引 哈希索引（hash index） 空间数据索引（R-Tree） 全文索引">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL之索引">
<meta property="og:url" content="http://example.com/2021/02/25/mysql-index/index.html">
<meta property="og:site_name" content="冰糕不冰的博客">
<meta property="og:description" content="在 MySQL 中，索引是在存储引擎层实现的，所以不同存储引擎即使支持同一类型索引，其实现方式也可能是不同的。 常见类型有：  B-Tree 索引 哈希索引（hash index） 空间数据索引（R-Tree） 全文索引">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2021/02/25/mysql-index/mysql-index.png">
<meta property="article:published_time" content="2021-02-25T10:01:30.000Z">
<meta property="article:modified_time" content="2021-03-01T01:47:18.161Z">
<meta property="article:author" content="MarksGui">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2021/02/25/mysql-index/mysql-index.png">

<link rel="canonical" href="http://example.com/2021/02/25/mysql-index/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>MySQL之索引 | 冰糕不冰的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">冰糕不冰的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/25/mysql-index/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MarksGui">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冰糕不冰的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          MySQL之索引
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-02-25 18:01:30" itemprop="dateCreated datePublished" datetime="2021-02-25T18:01:30+08:00">2021-02-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-03-01 09:47:18" itemprop="dateModified" datetime="2021-03-01T09:47:18+08:00">2021-03-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>在 MySQL 中，索引是在存储引擎层实现的，所以不同存储引擎即使支持同一类型索引，其实现方式也可能是不同的。</p>
<p>常见类型有：</p>
<ul>
<li>B-Tree 索引</li>
<li>哈希索引（hash index）</li>
<li>空间数据索引（R-Tree）</li>
<li>全文索引<span id="more"></span>
<h2 id="MySQL-索引"><a href="#MySQL-索引" class="headerlink" title="MySQL 索引"></a>MySQL 索引</h2></li>
</ul>
<p>索引在 MySQL 中页叫做”键(key)”，是存储引擎用于快速找到记录的一种数据结构。</p>
<h3 id="一、索引类型"><a href="#一、索引类型" class="headerlink" title="一、索引类型"></a>一、索引类型</h3><p>在 MySQL 中，索引是在存储引擎层实现的，所以不同存储引擎即使支持同一类型索引，其实现方式也可能是不同的。</p>
<p>常见类型有：</p>
<ul>
<li>B-Tree 索引</li>
<li>哈希索引（hash index）</li>
<li>空间数据索引（R-Tree）</li>
<li>全文索引</li>
</ul>
<h3 id="二、索引优点"><a href="#二、索引优点" class="headerlink" title="二、索引优点"></a>二、索引优点</h3><p>1.索引减少了服务器需要扫描的数据量</p>
<p>2.索引可以帮助服务器避免排序和临时表</p>
<p>3.索引可以将随机I/O变为顺序I/O</p>
<h3 id="三、如何创建高性能索引（InnoDB）"><a href="#三、如何创建高性能索引（InnoDB）" class="headerlink" title="三、如何创建高性能索引（InnoDB）"></a>三、如何创建高性能索引（InnoDB）</h3><h4 id="1-独立的列"><a href="#1-独立的列" class="headerlink" title="1.独立的列"></a>1.独立的列</h4><p>索引列不能是表达式的一部分，也不能是函数的参数。</p>
<p>例如，下面则无法使用 user_id 列的索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> user_id <span class="operator">+</span> <span class="number">1</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> FROM_UNIXTIME(created_at,format) <span class="operator">=</span> <span class="string">&#x27;2010-09-10&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>究其原因是因为B+Tree 数据结构查找数据是从根节点开始查找，根节点存储了索引的值，所以可以通过二分查找快速定位要需要的行，但是加上了表达式，则 MySQL 不得不一行一行的扫描然后计算判断。</p>
<h4 id="2-前缀索引和索引选择性"><a href="#2-前缀索引和索引选择性" class="headerlink" title="2.前缀索引和索引选择性"></a>2.前缀索引和索引选择性</h4><p>有时候我们需要为一个字符串创建索引，这时候可以使用 hash index，但有时候这样还不够，如果字符串非常长，如果整个字符串作为索引则非常占用空间，此时我们需要通过计算索引的选择性来创建前缀索引。</p>
<p>如 name 列里有一个叫 <code>ZhangSan</code> 的名字，如果按照长度5创建前缀索引，那么 MySQL 能索引到的部分就是 Zhang。那一个列我们到底应该创建多长的前缀索引才是最好的了？这时候就要用到索引的选择性这个知识点。</p>
<p><code>索引的选择性</code> ：不重复的索引值（也成为基数）和数据表的记录总数(T)的比值。 范围在1/T到1之间。选择性越高查询效率越高。</p>
<p>如何计算了：</p>
<p>a.先计算完整列的索引选择性:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT COUNT(DISTINCT clsbdh)&#x2F;COUNT(*) FROM vehicles;</span><br><span class="line">+---------------------------------+</span><br><span class="line">| COUNT(DISTINCT clsbdh)&#x2F;COUNT(*) |</span><br><span class="line">+---------------------------------+</span><br><span class="line">|                          0.9639 |</span><br><span class="line">+---------------------------------+</span><br></pre></td></tr></table></figure>

<p>b.计算不同长度前缀列的索引选择性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT COUNT(DISTINCT LEFT(clsbdh,13))&#x2F;COUNT(*) AS sel13,</span><br><span class="line">    -&gt; COUNT(DISTINCT LEFT(clsbdh,14))&#x2F;COUNT(*) AS sel14,</span><br><span class="line">    -&gt; COUNT(DISTINCT LEFT(clsbdh,15))&#x2F;COUNT(*) AS sel15,</span><br><span class="line">    -&gt; COUNT(DISTINCT LEFT(clsbdh,16))&#x2F;COUNT(*) AS sel16,</span><br><span class="line">    -&gt; COUNT(DISTINCT LEFT(clsbdh,17))&#x2F;COUNT(*) AS sel17</span><br><span class="line">    -&gt;  FROM vehicles;</span><br><span class="line">+--------+--------+--------+--------+--------+</span><br><span class="line">| sel13  | sel14  | sel15  | sel16  | sel17  |</span><br><span class="line">+--------+--------+--------+--------+--------+</span><br><span class="line">| 0.0277 | 0.0332 | 0.0423 | 0.1262 | 0.9639 |</span><br><span class="line">+--------+--------+--------+--------+--------+</span><br></pre></td></tr></table></figure>

<p>c.从 b 步奏的计算结果中找一个与 a 步奏计算结果最接近的值，这里发现长度为17时符合。这个是非常接近于1，说明该列数据大部分都不重复。</p>
<p>d.创建前缀索引</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE vehicles  ADD KEY (clsbdh(17));</span><br></pre></td></tr></table></figure>

<p>那如果需要后缀索引该怎么办了？比如要查找 @qq.com 域名的所有电子邮件地址。此时我们可以把字符串反转后存储，然后基于此创建前缀索引 KEY(col(7))，因为反转后moc.qq@长度为7。</p>
<h4 id="3-联合索引"><a href="#3-联合索引" class="headerlink" title="3.联合索引"></a>3.联合索引</h4><p>联合索引和多个独立的索引这两者经常被人搞混，我们先来看看这张表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CREATE TABLE &#96;user&#96; (</span><br><span class="line">  &#96;id&#96; int(11) NOT NULL,</span><br><span class="line">  &#96;name&#96; varchar(32) DEFAULT NULL,</span><br><span class="line">  &#96;age&#96; int(11) DEFAULT NULL,</span><br><span class="line">  &#96;class&#96; varchar(20),</span><br><span class="line">  &#96;last_name&#96; varchar(30),</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;),</span><br><span class="line">  KEY &#96;idx_age&#96; (&#96;age&#96;),</span><br><span class="line">  KEY &#96;idx_name_age&#96; (&#96;name&#96;,&#96;age&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB</span><br></pre></td></tr></table></figure>

<p>如上， <code>idx_age</code> 是独立的索引， <code>idx_name_age</code> 是联合索引。为 WHERE 条件里的列都单独创建一个索引其实是不太好，这样没办法优化。</p>
<p>联合索引 <code>key(name,age)</code> 的数据结构B+Tree示例图（参考）</p>
<p><img src="mysql-index.png" alt="image-20200815160654026"></p>
<p>可以看到根节点存储了键值，并且键值先按照 <code>age</code> 升序排列， <code>age</code>列相同时按照 <code>name</code> 排序，同时叶子节点存储了主键的值 ID1 、ID2等。</p>
<h5 id="回表"><a href="#回表" class="headerlink" title="回表"></a>回表</h5><p>对于下面的语句，执行过程：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> age <span class="operator">=</span> <span class="number">11</span> <span class="keyword">and</span> name <span class="operator">=</span> <span class="string">&#x27;aab&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>首先查找二级索引找到目标列，然后得到主键值为：ID1，此时在通过主键值到主键索引去查找到对应的行，读取对应行的数据。回到主键去查找的过程称为 <code>回表</code>。</p>
<p>使用联合索引要注意 <strong>最左前缀原则</strong>：</p>
<p>假设现在索引列为 key(age,name,class)：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> age <span class="operator">=</span> <span class="number">11</span> <span class="keyword">and</span> name <span class="operator">=</span> <span class="string">&#x27;aab&#x27;</span> <span class="keyword">and</span> class <span class="operator">=</span> <span class="string">&#x27;三年级一班&#x27;</span>; </span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> age <span class="operator">=</span> <span class="number">11</span> <span class="keyword">and</span> name <span class="operator">=</span> <span class="string">&#x27;aab&#x27;</span>; </span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> age <span class="operator">=</span> <span class="number">11</span>; </span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> age <span class="operator">=</span> <span class="number">11</span> <span class="keyword">and</span> name <span class="keyword">like</span> <span class="string">&#x27;%a&#x27;</span>; </span><br></pre></td></tr></table></figure>

<p>以上语句都能使用到索引，因为都是按照联合索引创建顺序来查找的。而下面的语句则用不到索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 用不到任何索引</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;aab&#x27;</span> <span class="keyword">and</span> class <span class="operator">=</span> <span class="string">&#x27;三年级一班&#x27;</span>; </span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> class <span class="operator">=</span> <span class="string">&#x27;三年级一班&#x27;</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 只有第一列能用到索引</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> age <span class="operator">=</span> <span class="number">11</span> <span class="keyword">and</span> class <span class="operator">=</span> <span class="string">&#x27;三年级一班&#x27;</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">-- class 列用不到索引，因为 name 列使用了范围查询，&gt;、&lt; 也算是范围</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> age <span class="operator">=</span> <span class="number">11</span> <span class="keyword">and</span> name <span class="keyword">like</span> <span class="string">&#x27;%a&#x27;</span> <span class="keyword">and</span> class <span class="operator">=</span> <span class="string">&#x27;三年级一班&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>所以有需要范围查询的列，我们就把索引安排在最后即可。</p>
<p>其实回头查看下联合索引的数据结构思考就能明白，因为索引创建的时候已经是排好序的，第一列相同的情况下，会按照第二列排序，然后是第三列。所以查找的时候只能从第一列开始查找，如果改变顺序，则需要全表扫描。</p>
<p>按照最左匹配原则下面的语句能用到索引吗？</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;aab&#x27;</span> <span class="keyword">and</span> age <span class="operator">=</span>  <span class="number">11</span> <span class="keyword">and</span> class <span class="operator">=</span> <span class="string">&#x27;三年级一班&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>答案是能用到索引，不信请看执行结果：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;aab&#x27;</span> <span class="keyword">and</span> age <span class="operator">=</span>  <span class="number">11</span> <span class="keyword">and</span> class <span class="operator">=</span> <span class="string">&#x27;三年级一班&#x27;</span>\G;</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">           id: <span class="number">1</span></span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        <span class="keyword">table</span>: <span class="keyword">user</span></span><br><span class="line">   partitions: <span class="keyword">NULL</span></span><br><span class="line">         type: <span class="keyword">ref</span></span><br><span class="line">possible_keys: idx</span><br><span class="line">          key: idx</span><br><span class="line">      key_len: <span class="number">248</span></span><br><span class="line">          <span class="keyword">ref</span>: const,const,const</span><br><span class="line">         <span class="keyword">rows</span>: <span class="number">1</span></span><br><span class="line">     filtered: <span class="number">100.00</span></span><br><span class="line">        Extra: <span class="keyword">Using</span> index</span><br></pre></td></tr></table></figure>

<p>这… 不是说要符合最左前缀原则才能使用索引吗？我真的方了。</p>
<p>其实原因在于 MySQL 查询优化器帮我们调整了顺序，实际执行的语句还是如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> age <span class="operator">=</span> <span class="number">11</span> <span class="keyword">and</span> name <span class="operator">=</span> <span class="string">&#x27;aab&#x27;</span> <span class="keyword">and</span> class <span class="operator">=</span> <span class="string">&#x27;三年级一班&#x27;</span>; </span><br></pre></td></tr></table></figure>

<p>经过实验结果，只有第一列和第二列会帮我们优化，后面的列还是要自己注意顺序。</p>
<h5 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h5><p>那对于不符合最左前缀的列是怎么处理的了：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> age <span class="operator">=</span> <span class="number">11</span> <span class="keyword">and</span> class <span class="operator">=</span> <span class="string">&#x27;三年级一班&#x27;</span>; </span><br></pre></td></tr></table></figure>

<p>在MySQL5.6之后引入的索引下推优化（index condition pushdown)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少<code>回表</code>次数。如果条件里面里面不含有索引列，那还是需要回到主键索引去搜索。</p>
<h3 id="4-选择合适的索引列顺序"><a href="#4-选择合适的索引列顺序" class="headerlink" title="4.选择合适的索引列顺序"></a>4.选择合适的索引列顺序</h3><p>还是以上面的表为例子，我们可以创建索引 KEY(name,age) 或者 KEY(age,name)。哪种最好了？我们此时可以看哪个列的选择性更高。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> name) <span class="operator">/</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> name_selectivity</span><br><span class="line">	, <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> age) <span class="operator">/</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> age_selectivity</span><br><span class="line">	, <span class="built_in">COUNT</span>(<span class="operator">*</span>) </span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+-----------------+----------+</span></span><br><span class="line"><span class="operator">|</span> name_selectivity <span class="operator">|</span> age_selectivity <span class="operator">|</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+--------+--------+----------+</span></span><br><span class="line"><span class="operator">|</span>     <span class="number">0.0005</span>       <span class="operator">|</span>      <span class="number">0.9962</span>     <span class="operator">|</span>  <span class="number">2945454</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+-----------------+----------+</span></span><br></pre></td></tr></table></figure>

<p>age 的选择性更高，应该创建索引 KEY(name,age)。</p>
<h3 id="5-聚簇索引"><a href="#5-聚簇索引" class="headerlink" title="5.聚簇索引"></a>5.聚簇索引</h3><p>聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。“聚簇”表示数据行和相邻的键值紧凑地存储在一起。InnoDB 的聚簇索引就是主键。如果表没有定义主键，InnoDB会选择一个唯一的非空索引代替。如果没有这样的索引，InnoDB 会隐式定义一个主键来作为聚簇索引。</p>
<p>我们尽量避免使用随机的（不连续切值得分布范围非常大）聚簇索引。例如使用 UUID 来作为聚簇索引。它会让聚簇索引的插入变得完全随机。同时UUID值非常长，索引占用空间也会变大。</p>
<h3 id="6-覆盖索引"><a href="#6-覆盖索引" class="headerlink" title="6.覆盖索引"></a>6.覆盖索引</h3><p>索引包含所有需要查询的字段的值，我们就成为覆盖索引。</p>
<p>假设此时联合索引为：key(age,name,class)：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> age <span class="operator">=</span> <span class="number">11</span> <span class="keyword">and</span> name <span class="operator">=</span> <span class="string">&#x27;aab&#x27;</span> <span class="keyword">and</span> class <span class="operator">=</span> <span class="string">&#x27;三年级一班&#x27;</span>; </span><br></pre></td></tr></table></figure>

<p>按照上面的方式，每查询一次都要回表到主键索引去拿整行数据。如果改成下面这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> age,name,class <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> age <span class="operator">=</span> <span class="number">11</span> <span class="keyword">and</span> name <span class="operator">=</span> <span class="string">&#x27;aab&#x27;</span> <span class="keyword">and</span> class <span class="operator">=</span> <span class="string">&#x27;三年级一班&#x27;</span>; </span><br></pre></td></tr></table></figure>

<p>此时由于二级索引中存储了索引列的值，所以此时可以直接从索引列获取，避免了对主键索引的二次查询。</p>
<p>覆盖索引对 InnoDB 非常管用，而哈希索引、空间索引、全文索引都不会存储索引列的值，所以没办法使用覆盖索引。</p>
<h3 id="7-使用索引扫描来做排序"><a href="#7-使用索引扫描来做排序" class="headerlink" title="7.使用索引扫描来做排序"></a>7.使用索引扫描来做排序</h3><p>如果 EXPLAIN 出来的 type 列的值为“index”，则说明使用了索引扫描来排序。</p>
<p>只有当索引的列顺序和 ORDER BY 子句的顺序完全一致，并且所有列的排序方向（倒序或正序）都一样时，才能使用索引来对结果做排序。如果查询关联了多张表，则只有当 ORDER BY 子句引用的字段全部为第一个表时，才能使用索引做排序。ORDER BY 子句和查询限制一样，都要求满足最左前缀原则。</p>
<p>但有一种情况即使不满足，也可以使用最左前缀排序。索引的第一列被指定为一个常数，此时也可以使用到索引排序。如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> age,name,class <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> age <span class="operator">=</span> <span class="number">11</span> <span class="keyword">order</span> <span class="keyword">by</span> name,class\G;</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">         type: <span class="keyword">ref</span></span><br><span class="line">possible_keys: idx</span><br><span class="line">          key: idx</span><br><span class="line">          <span class="keyword">ref</span>: const</span><br><span class="line">         <span class="keyword">rows</span>: <span class="number">1</span></span><br><span class="line">        Extra: <span class="keyword">Using</span> <span class="keyword">where</span>; <span class="keyword">Using</span> index</span><br></pre></td></tr></table></figure>

<p>下面是一些不能使用索引做排序的查询：</p>
<ul>
<li><p>使用了两种不同的排序方向</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">... <span class="keyword">where</span> age <span class="operator">=</span> <span class="number">11</span> <span class="keyword">order</span> <span class="keyword">by</span> name <span class="keyword">desc</span>,class <span class="keyword">asc</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ORDER BY 子句中引用了一个不存在索引中的列</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">... <span class="keyword">where</span> age <span class="operator">=</span> <span class="number">11</span> <span class="keyword">order</span> <span class="keyword">by</span> name,last_name;</span><br></pre></td></tr></table></figure>
</li>
<li><p>WHERE 和 ORDER BY 中的列无法组合成索引得最左前缀</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">... <span class="keyword">where</span> age <span class="operator">=</span> <span class="number">11</span> <span class="keyword">order</span> <span class="keyword">by</span> class;</span><br></pre></td></tr></table></figure>
</li>
<li><p>索引的第一列上是范围条件，所以后面的列无法使用索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">... <span class="keyword">where</span> age <span class="operator">&gt;</span> <span class="number">11</span> <span class="keyword">order</span> <span class="keyword">by</span> name,class;</span><br></pre></td></tr></table></figure>
</li>
<li><p>name 列上有多个等于条件。对于排序来说，这也是一种范围查询。但是对于where条件的查询则不算范围查询。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">... <span class="keyword">where</span> age <span class="operator">=</span> <span class="number">11</span> <span class="keyword">and</span> name <span class="keyword">in</span> (<span class="string">&#x27;abc&#x27;</span>,<span class="string">&#x27;bcd&#x27;</span>) <span class="keyword">order</span> <span class="keyword">by</span> class;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p>###四、总结</p>
<p>上面我们讲解了 MySQL 中的索引用法，我们平时在使用的时候要根据业务需要考虑所有列，创建合适的索引和使用合适的 sql 语句。我们要尽可能使用联合索引，并将范围查询的列放到索引靠后的位置，同时要避免多个范围条件的查询。如果能使用覆盖索引则是最好的。</p>
<blockquote>
<p>参考资料：</p>
<p>《高性能MySQL》、丁奇老师专栏《MySQL实战45讲》</p>
</blockquote>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/02/25/hello-world/" rel="prev" title="Hello World">
      <i class="fa fa-chevron-left"></i> Hello World
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL-%E7%B4%A2%E5%BC%95"><span class="nav-number">1.</span> <span class="nav-text">MySQL 索引</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.1.</span> <span class="nav-text">一、索引类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E7%B4%A2%E5%BC%95%E4%BC%98%E7%82%B9"><span class="nav-number">1.2.</span> <span class="nav-text">二、索引优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E7%B4%A2%E5%BC%95%EF%BC%88InnoDB%EF%BC%89"><span class="nav-number">1.3.</span> <span class="nav-text">三、如何创建高性能索引（InnoDB）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E7%8B%AC%E7%AB%8B%E7%9A%84%E5%88%97"><span class="nav-number">1.3.1.</span> <span class="nav-text">1.独立的列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95%E5%92%8C%E7%B4%A2%E5%BC%95%E9%80%89%E6%8B%A9%E6%80%A7"><span class="nav-number">1.3.2.</span> <span class="nav-text">2.前缀索引和索引选择性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95"><span class="nav-number">1.3.3.</span> <span class="nav-text">3.联合索引</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9B%9E%E8%A1%A8"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">回表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8"><span class="nav-number">1.3.3.2.</span> <span class="nav-text">索引下推</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E7%B4%A2%E5%BC%95%E5%88%97%E9%A1%BA%E5%BA%8F"><span class="nav-number">1.4.</span> <span class="nav-text">4.选择合适的索引列顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95"><span class="nav-number">1.5.</span> <span class="nav-text">5.聚簇索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="nav-number">1.6.</span> <span class="nav-text">6.覆盖索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E6%89%AB%E6%8F%8F%E6%9D%A5%E5%81%9A%E6%8E%92%E5%BA%8F"><span class="nav-number">1.7.</span> <span class="nav-text">7.使用索引扫描来做排序</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">MarksGui</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">2</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">MarksGui</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
